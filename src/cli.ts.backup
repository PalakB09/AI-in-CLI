#!/usr/bin/env node
import dotenv from "dotenv";
import path from "path";

dotenv.config({
  path: path.resolve(process.cwd(), ".env"),
  override: true,
});
console.log(
  "[ENV]",
  "CWD =", process.cwd(),
  "| GEMINI_API_KEY =",
  process.env.GEMINI_API_KEY?.slice(0, 6) || "NOT FOUND"
);


import { Command } from "commander";
import chalk from "chalk";
import { AIService } from "./core/ai-service";
import { ShellIntegrator } from "./shell/shell-integrator";
import { CommandResolver } from "./resolver/command-resolver";
import { SafetyValidator } from "./safety/safety-validator";
import { StorageManager } from "./storage/storage-manager";
import { OSAdapter } from "./os/os-adapter";
import { PluginManager } from "./plugins/plugin-manager";
import { ResolvedCommand } from "./types";

const program = new Command();

program
  .name("ai")
  .description("AI-powered command assistant for existing terminals")
  .version("1.0.0");

program
  .command("suggest")
  .description("Get command suggestions for natural language input")
  .argument("<input...>", "Natural language description of desired action")
  .option("-e, --explain", "Explain the suggested command before execution")
  .option("-d, --dry-run", "Show what would be executed without running")
  .option("--shell <shell>", "Specify shell type (bash/zsh/powershell/cmd)")
  .action(async (inputParts: string[], options) => {
    console.log('RAW INPUT Parts:', inputParts);
    const input = inputParts.join(" ");
    console.log('RAW INPUT:', input);
    try {
      const aiService = new AIService();
      const resolver = new CommandResolver(aiService);

      const validator = new SafetyValidator();
      const osAdapter = new OSAdapter();
      const pluginManager = new PluginManager();
      await pluginManager.loadPlugins();

      const resolvedCommand = await resolver.resolve(input, osAdapter.getOS());

      if (!resolvedCommand) {
        console.log(
          chalk.yellow("Could not resolve your request to a command."),
        );
        return;
      }

      const safetyResult = await validator.validate(resolvedCommand);

      if (options.explain || safetyResult.warning) {
        console.log(chalk.blue("Command explanation:"));
        console.log(resolvedCommand.explanation || "No explanation available");
        console.log("");
      }

      if (safetyResult.blocked) {
        console.log(chalk.red("⚠️  SAFETY BLOCK: ") + safetyResult.reason);
        return;
      }

      if (safetyResult.warning) {
        console.log(
          chalk.yellow("⚠️  SAFETY WARNING: ") + safetyResult.warning,
        );
      }

      // Handle variables
      let finalCommands = [...resolvedCommand.commands];
      if (resolvedCommand.variables) {
        const inquirer = require("inquirer");
        const variablePrompts = Object.keys(resolvedCommand.variables).map(varName => ({
          type: "input",
          name: varName,
          message: `Enter value for ${varName}:`,
        }));
        const answers = await inquirer.prompt(variablePrompts);
        finalCommands = finalCommands.map(cmd => {
          let substituted = cmd;
          for (const [varName, value] of Object.entries(answers)) {
            substituted = substituted.replace(new RegExp(`\\{${varName}\\}`, 'g'), String(value));
          }
          return substituted;
        });
      }

      console.log(chalk.green("Suggested commands:"));
      finalCommands.forEach((cmd, index) => {
        console.log(`${index + 1}. ${chalk.cyan(cmd)}`);
      });

      if (!options.dryRun && !safetyResult.blocked) {
        const inquirer = require("inquirer");

        if (finalCommands.length > 1) {
          console.log("\nThis is a multi-step workflow. Each step will be confirmed separately.");
        }

        for (let i = 0; i < finalCommands.length; i++) {
          const cmd = finalCommands[i];
          console.log(`\n${chalk.blue("Step " + (i + 1) + ":")} ${chalk.cyan(cmd)}`);

          const { shouldExecute } = await inquirer.prompt([
            {
              type: "confirm",
              name: "shouldExecute",
              message: finalCommands.length > 1 ? `Execute step ${i + 1}?` : "Execute this command?",
              default: false,
            },
          ]);

          if (!shouldExecute) {
            console.log(chalk.yellow("Step skipped."));
            continue;
          }

          const { execSync } = require("child_process");
          try {
            const isWindows = process.platform === "win32";

            if (isWindows) {
              execSync(`powershell -Command "${cmd}"`, {
                stdio: "inherit",
              });
            } else {
              execSync(cmd, { stdio: "inherit" });
            }
            console.log(chalk.green(`Step ${i + 1} completed successfully.`));
            pluginManager.onCommandExecuted(resolvedCommand, true);
          } catch (error) {
            console.error(
              chalk.red(`Step ${i + 1} failed:`),
              error instanceof Error ? error.message : String(error),
            );
            pluginManager.onCommandExecuted(resolvedCommand, false);
            const { continueWorkflow } = await inquirer.prompt([
              {
                type: "confirm",
                name: "continueWorkflow",
                message: "Continue with remaining steps?",
                default: false,
              },
            ]);
            if (!continueWorkflow) {
              break;
            }
          }
        }
      }
    } catch (error) {
      console.error(chalk.red("Error:"), error instanceof Error ? error.message : String(error));
      process.exit(1);
    }
  });

program
  .command("install")
  .description("Install shell integration")
  .option("--shell <shell>", "Shell type (bash/zsh/powershell/cmd)")
  .action(async (options) => {
    try {
      const integrator = new ShellIntegrator();
      await integrator.install(options.shell);
      console.log(chalk.green("✓ Shell integration installed successfully"));
    } catch (error) {
      console.error(chalk.red("Installation failed:"), error instanceof Error ? error.message : String(error));
    }
  });

program
  .command("uninstall")
  .description("Remove shell integration")
  .option("--shell <shell>", "Shell type (bash/zsh/powershell/cmd)")
  .action(async (options) => {
    try {
      const integrator = new ShellIntegrator();
      await integrator.uninstall(options.shell);
      console.log(chalk.green("✓ Shell integration removed successfully"));
    } catch (error) {
      console.error(chalk.red("Uninstallation failed:"), error instanceof Error ? error.message : String(error));
    }
  });

program
// Vault management commands
program
  .command("vault")
  .description("Manage command vault");

program
  .command("vault:list")
  .alias("vault")
  .description("List all stored commands")
  .action(async () => {
    try {
      const storage = new StorageManager();
      const allCommands = await storage.getAllCommands();
      console.table(allCommands.map(cmd => ({
        id: cmd.id,
        name: cmd.name || '',
        commands: cmd.commands.join('; '),
        description: cmd.description,
        tags: cmd.tags.join(', '),
        usageCount: cmd.usageCount,
        source: cmd.source
      })));
    } catch (error) {
      console.error(chalk.red("Error listing vault:"), error.message);
    }
  });

program
  .command("vault:search")
  .description("Search commands in vault")
  .argument("<query>", "Search query")
  .action(async (query) => {
    try {
      const storage = new StorageManager();
      const results = await storage.searchCommands(query);
      console.table(results.map(cmd => ({
        id: cmd.id,
        name: cmd.name || '',
        commands: cmd.commands.join('; '),
        description: cmd.description,
        tags: cmd.tags.join(', '),
        confidence: cmd.confidence
      })));
    } catch (error) {
      console.error(chalk.red("Error searching vault:"), error.message);
    }
  });

program
  .command("vault:add")
  .description("Add a command to vault")
  .argument("<command>", "Command or script to add")
  .option("-n, --name <name>", "Custom name for the command")
  .option("-d, --description <description>", "Description for the command")
  .action(async (command, options) => {
    try {
      const storage = new StorageManager();
      // Split on ; or && for multi-command scripts
      const cmdArray = command.split(/\s*(&&|;)\s*/).filter((cmd: string) => cmd && !['&&', ';'].includes(cmd));
      await storage.addCommand(
        cmdArray.length > 1 ? cmdArray : command,
        options.description,
        [],
        'user',
        0.7,
        undefined,
        options.name
      );
      console.log(chalk.green(cmdArray.length > 1 ? "✓ Script added to vault" : "✓ Command added to vault"));
    } catch (error) {
      console.error(chalk.red("Error adding command:"), error.message);
    }
  });

program
  .command("vault:run")
  .description("Run a stored command by ID or name")
  .argument("<idOrName>", "Command ID or custom name")
  .action(async (idOrName) => {
    try {
      const storage = new StorageManager();
      const allCmds = await storage.getAllCommands();
      let cmdToRun = allCmds.find(cmd => cmd.id === idOrName);
      
      // If not found by ID, try to find by name
      if (!cmdToRun) {
        cmdToRun = allCmds.find(cmd => cmd.name === idOrName);
      }
      
      if (!cmdToRun) {
        console.log(chalk.red(`Command with ID or name '${idOrName}' not found`));
        return;
      }
      
      // Increment usage
      await storage.incrementUsage(cmdToRun.id);
      
      // Execute the command like in suggest
      const resolvedCommand: ResolvedCommand = {
        commands: cmdToRun.commands,
        explanation: cmdToRun.description,
        tags: cmdToRun.tags,
        confidence: cmdToRun.confidence,
        source: cmdToRun.source as any,
        variables: cmdToRun.variables
      };

      const validator = new SafetyValidator();
      const osAdapter = new OSAdapter();
      const pluginManager = new PluginManager();
      await pluginManager.loadPlugins();

      const safetyResult = await validator.validate(resolvedCommand);

      if (safetyResult.warning) {
        console.log(
          chalk.yellow("⚠️  SAFETY WARNING: ") + safetyResult.warning,
        );
      }

      // Handle variables
      let finalCommands = [...resolvedCommand.commands];
      if (resolvedCommand.variables) {
        const inquirer = require("inquirer");
        const variablePrompts = Object.keys(resolvedCommand.variables).map(varName => ({
          type: "input",
          name: varName,
          message: `Enter value for ${varName}:`,
        }));
        const answers = await inquirer.prompt(variablePrompts);
        finalCommands = finalCommands.map(cmd => {
          let substituted = cmd;
          for (const [varName, value] of Object.entries(answers)) {
            substituted = substituted.replace(new RegExp(`\\{${varName}\\}`, 'g'), value as string);
          }
          return substituted;
        });
      }

      console.log(chalk.green("Running script:"));
      finalCommands.forEach((cmd, index) => {
        console.log(`${index + 1}. ${chalk.cyan(cmd)}`);
      });

      if (finalCommands.length === 1) {
        // Single command - ask for confirmation
        const inquirer = require("inquirer");
        const { confirmed } = await inquirer.prompt([{
          type: "confirm",
          name: "confirmed",
          message: "Execute this command?",
          default: false
        }]);

        if (!confirmed) {
          console.log(chalk.yellow("Command execution cancelled."));
          return;
        }

        // Execute single command
        const { exec } = require("child_process");
        const child = exec(finalCommands[0], { cwd: process.cwd() });

        child.stdout?.on("data", (data: Buffer) => {
          process.stdout.write(data);
        });

        child.stderr?.on("data", (data: Buffer) => {
          process.stderr.write(data);
        });

        await new Promise((resolve, reject) => {
          child.on("close", (code: number) => {
            if (code === 0) {
              resolve(void 0);
            } else {
              reject(new Error(`Command failed with exit code ${code}`));
            }
          });
          child.on("error", reject);
        });
      } else {
        // Multi-command script - ask for each step
        const inquirer = require("inquirer");
        const { exec } = require("child_process");

        for (let i = 0; i < finalCommands.length; i++) {
          const cmd = finalCommands[i];
          console.log(chalk.blue(`\nStep ${i + 1}: ${chalk.cyan(cmd)}`));
          
          const { confirmed } = await inquirer.prompt([{
            type: "confirm",
            name: "confirmed",
            message: `Execute step ${i + 1}?`,
            default: false
          }]);

          if (!confirmed) {
            console.log(chalk.yellow(`Step ${i + 1} skipped.`));
            continue;
          }

          const child = exec(cmd, { cwd: process.cwd() });

          child.stdout?.on("data", (data: Buffer) => {
            process.stdout.write(data);
          });

          child.stderr?.on("data", (data: Buffer) => {
            process.stderr.write(data);
          });

          await new Promise((resolve, reject) => {
            child.on("close", (code: number) => {
              if (code === 0) {
                resolve(void 0);
              } else {
                reject(new Error(`Step ${i + 1} failed with exit code ${code}`));
              }
            });
            child.on("error", reject);
          });
        }
      }
    } catch (error) {
      console.error(chalk.red("Error running command:"), error.message);
    }
  });

program
  .command("debug")
  .description("Show debugging information")
        case "list":
          const allCommands = await storage.getAllCommands();
          console.table(allCommands.map(cmd => ({
            id: cmd.id,
            name: cmd.name || '',
            commands: cmd.commands.join('; '),
            description: cmd.description,
            tags: cmd.tags.join(', '),
            usageCount: cmd.usageCount,
            source: cmd.source
          })));
          break;
        case "search":
          const results = await storage.searchCommands(query);
          console.table(results.map(cmd => ({
            id: cmd.id,
            name: cmd.name || '',
            commands: cmd.commands.join('; '),
            description: cmd.description,
            tags: cmd.tags.join(', '),
            confidence: cmd.confidence
          })));
          break;
        case "add":
          if (!query) {
            console.log(chalk.red("Please provide a command or script to add"));
            return;
          }
          // For add action, the query should be the command, and options are used for name/description
          const cmdArray = query.split(/\s*(&&|;)\s*/).filter((cmd: string) => cmd && !['&&', ';'].includes(cmd));
          await storage.addCommand(
            cmdArray.length > 1 ? cmdArray : query,
            options.description,
            [],
            'user',
            0.7,
            undefined,
            options.name
          );
          console.log(chalk.green(cmdArray.length > 1 ? "✓ Script added to vault" : "✓ Command added to vault"));
          break;
        case "run":
          if (!query) {
            console.log(chalk.red("Please provide a command ID or name to run"));
            return;
          }
          const allCmds = await storage.getAllCommands();
          let cmdToRun = allCmds.find(cmd => cmd.id === query);
          
          // If not found by ID, try to find by name
          if (!cmdToRun) {
            cmdToRun = allCmds.find(cmd => cmd.name === query);
          }
          
          if (!cmdToRun) {
            console.log(chalk.red(`Command with ID or name '${query}' not found`));
            return;
          }
          
          // Increment usage
          await storage.incrementUsage(cmdToRun.id);
          
          // Execute the command like in suggest
          const resolvedCommand: ResolvedCommand = {
            commands: cmdToRun.commands,
            explanation: cmdToRun.description,
            tags: cmdToRun.tags,
            confidence: cmdToRun.confidence,
            source: cmdToRun.source as any,
            variables: cmdToRun.variables
          };

          const validator = new SafetyValidator();
          const osAdapter = new OSAdapter();
          const pluginManager = new PluginManager();
          await pluginManager.loadPlugins();

          const safetyResult = await validator.validate(resolvedCommand);

          if (safetyResult.warning) {
            console.log(
              chalk.yellow("⚠️  SAFETY WARNING: ") + safetyResult.warning,
            );
          }

          // Handle variables
          let finalCommands = [...resolvedCommand.commands];
          if (resolvedCommand.variables) {
            const inquirer = require("inquirer");
            const variablePrompts = Object.keys(resolvedCommand.variables).map(varName => ({
              type: "input",
              name: varName,
              message: `Enter value for ${varName}:`,
            }));
            const answers = await inquirer.prompt(variablePrompts);
            finalCommands = finalCommands.map(cmd => {
              let substituted = cmd;
              for (const [varName, value] of Object.entries(answers)) {
                substituted = substituted.replace(new RegExp(`\\{${varName}\\}`, 'g'), value as string);
              }
              return substituted;
            });
          }

          console.log(chalk.green("Running script:"));
          finalCommands.forEach((cmd, index) => {
            console.log(`${index + 1}. ${chalk.cyan(cmd)}`);
          });

          if (safetyResult.blocked) {
            console.log(chalk.red("⚠️  SAFETY BLOCK: ") + safetyResult.reason);
            return;
          }

          const inquirer = require("inquirer");

          if (finalCommands.length > 1) {
            console.log("\nThis is a multi-step script. Each step will be confirmed separately.");
          }

          for (let i = 0; i < finalCommands.length; i++) {
            const cmd = finalCommands[i];
            console.log(`\n${chalk.blue("Step " + (i + 1) + ":")} ${chalk.cyan(cmd)}`);

            const { shouldExecute } = await inquirer.prompt([
              {
                type: "confirm",
                name: "shouldExecute",
                message: finalCommands.length > 1 ? `Execute step ${i + 1}?` : "Execute this command?",
                default: false,
              },
            ]);

            if (!shouldExecute) {
              console.log(chalk.yellow("Step skipped."));
              continue;
            }

            const { execSync } = require("child_process");
            try {
              const isWindows = process.platform === "win32";

              if (isWindows) {
                execSync(`powershell -Command "${cmd}"`, {
                  stdio: "inherit",
                });
              } else {
                execSync(cmd, { stdio: "inherit" });
              }
              console.log(chalk.green(`Step ${i + 1} completed successfully.`));
              pluginManager.onCommandExecuted(resolvedCommand, true);
            } catch (error) {
              console.error(
                chalk.red(`Step ${i + 1} failed:`),
                error instanceof Error ? error.message : String(error),
              );
              pluginManager.onCommandExecuted(resolvedCommand, false);
              const { continueWorkflow } = await inquirer.prompt([
                {
                  type: "confirm",
                  name: "continueWorkflow",
                  message: "Continue with remaining steps?",
                  default: false,
                },
              ]);
              if (!continueWorkflow) {
                break;
              }
            }
          }
          break;
        default:
          console.log(
            chalk.red("Invalid action. Use: list, search, add, run"),
          );
      }
    } catch (error) {
      console.error(chalk.red("Error:"), error instanceof Error ? error.message : String(error));
    }
  });

program
  .command("debug")
  .description("Show debugging information")
  .action(() => {
    const osAdapter = new OSAdapter();
    console.log(chalk.blue("Debug Information:"));
    console.log("OS:", osAdapter.getOS());
    console.log("Shell:", process.env.SHELL || "Unknown");
    console.log("Node Version:", process.version);
    console.log("Working Directory:", process.cwd());
  });

async function main() {
  await program.parseAsync(process.argv);
}

main().catch((err) => {
  console.error("Fatal error:", err);
  process.exit(1);
});
